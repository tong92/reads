# 브랜치 전략

- 코드베이스의 특정 시점에서 시작
- 코드를 어떻게 발전 시킬지 일치 되지 않을때 분할
	
## 브랜치 이해하기

- 분기된 커밋을 지정하는 포인터
- 새로운 구상을 시험해보기 위해, 버그수정, 리팩토링..
- 브랜치를 공유하면 다른 사용자와 커밋 추가가 겹칠경우 병합 충돌이 일어남		

## 규약 선택하기

- 작업표준
- 문서화
- 진입장벽이 낮아짐
- 릴리즈, 요구사항에 따라 전략을 선택

## 규약

### 메인라인 브랜치 개발

- 중앙(master)에 작업을 커밋
- 완성 버전만 중앙에 커밋되어야 함
- 장점

	- 문제 확인이 쉬움
	- 배포 자동화시 웹 서비스에선 유저에게 최신버전을 유지

- 단점

	- 테스트가 없다면 중앙에 올린 코드가 완료된 코드라 보기 힘듬
	- 웹을 제외한 서비스에선 업데이트가 잦음
	- 사용하지 않는 코드 정리가 필요함

### 기능별 브랜치 배포

- 기능브랜치와 통합브랜츠로 분리
- 기능 브랜치는 온전한 기능 단위로 커밋
- 통합 브랜치는 다른 개발자의 기능 브랜치와 통합
- 기능 브랜치 생성시 해당하는 기능명으로 브랜치 생성
- 에러 체크 후 병합, 재배포 결정
- 장점

	- 빠른 코드 배포에 초점
	- 어떤 기능을 배포할지 선택하는 과정 추가

- 단점

	- 코드를 동기화 하는 과정 필요
	- 브랜치명이 익숙하지 않으면 진입장벽이 생김
	- 통합된 브랜치를 삭제하는 작업 추가

### 상태 브랜칭

- 브랜치 네이밍을 통해 코드가 어떤 환경에 사용될 것인지 명시
- 개발 -> 준비 -> 출시 (올라갈수록 커밋수는 줄어듬) 
- 장점

	- 브랜치명은 구체적인 작업 상황을 설명하고 작업과 관계가 있음
	- 자신이 병합해야 할 브랜치를 찾기 쉬움

- 단점

	- 프로젝트간 일관성 유지가 힘듬. 진입장벽이 높음

### 정기배포

- 배포가 제한적일 경우(일정 기간에만 배포)
- 이슈 티켓별로 브랜치 생성, 개발브랜치에 병합
- 특정 시점에 개발브랜치에서 릴리즈 브랜치 분기
- 릴리즈 브랜치는 버그만 수정(이후 개발된 기능은 통합되지 않는다)
- 긴급 사항을 정확히 규정하자
- 마스터로 배포하며 태깅
- 핫 픽스시 수정하며 태깅(마스터 브랜치에서 분기, 마스터, 개발 브랜치에 반영)
- 장점 

	- 테스트 타겟이 작아짐(티켓별로 브랜치)
	- 일반적인 작업 과정과 비슷
	- 규약 지켜진다면 작업 브랜치를 파악하기 쉬움

- 단점

	- 익숙하지 않은 개발자들에겐 진입장벽이 있다
	- 잘못된 브랜치에서 개발을 시작할 경우 복구하기 쉽지 않다

## 브랜치 업데이트하기

- 원격서버에서 클론 -> 로컬작업 
- 원격서베에서 fetch -> merge or rebase 로 작업과 병합
- merge 

	- 병합이 rebase보단 쉬움
	- 마스터 브랜치에 자신의 작업 커밋까지 섞여 들어가 히스토리가 복잡해짐

- rebase

	- 분리된 브랜치 포인터를 해당 브랜치 헤드로 이동
	- 병합이 어려울 수 있음
	- 히스토리가 깔끔함

